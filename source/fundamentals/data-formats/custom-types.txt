.. _pymongo-custom-types:

============
Custom Types
============

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: tutorial

.. meta::
   :keywords: codec, serialize, deserialize

Overview
--------

In this guide, you can learn how to create a custom type with {+driver-short+}.
This guide describes how to subclass ``~bson.codec_options.TypeCodec`` to write a type
codec, which you can use to populate a ``~bson.codec_options.TypeRegistry``.
You can then use the type registry to create a custom-type-aware
``~pymongo.collection.Collection``. Read and write operations
issued against the resulting collection object transparently manipulate
documents as they are saved to or retrieved from MongoDB.

Setting Up
----------

First, create a new database:

.. code-block:: python

   >>> from pymongo import MongoClient
   >>> client = MongoClient()
   >>> client.drop_database("custom_type_example")
   >>> db = client.custom_type_example


This example uses the ``~decimal.Decimal`` type from Python's standard library. The
BSON library's ``~bson.decimal128.Decimal128`` type, which implements
the IEEE 754 decimal128 decimal-based floating-point numbering format, is
distinct from Python's built-in ``~decimal.Decimal`` type. Trying
to save an instance of ``Decimal`` with PyMongo results in a
``~bson.errors.InvalidDocument`` exception.

.. code-block:: python

   >>> from decimal import Decimal
   >>> num = Decimal("45.321")
   >>> db.test.insert_one({"num": num})
   Traceback (most recent call last):
   ...
   bson.errors.InvalidDocument: cannot encode object: Decimal('45.321'), of type: <class 'decimal.Decimal'>

.. _custom-type-type-codec:

The ``~bson.codec_options.TypeCodec`` Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 3.8

To encode a custom type, you must first define a **type codec** for
that type. A type codec describes how an instance of a custom type can be
*transformed* to and from one of the types ``~bson`` already understands.
Depending on the desired functionality, you must choose from the following
base classes when defining type codecs:

- ``~bson.codec_options.TypeEncoder``: Subclass this to define a codec that
  encodes a custom Python type to a known BSON type. You must implement the
  ``python_type`` property and the ``transform_python()`` method.
- ``~bson.codec_options.TypeDecoder``: Subclass this to define a codec that
  decodes a specified BSON type into a custom Python type. You must implement
  the ``bson_type`` property and the ``transform_bson()`` method.
- ``~bson.codec_options.TypeCodec``: Subclass this to define a codec that
  can both encode and decode a custom type. You must implement the
  ``python_type`` and ``bson_type`` properties, and the
  ``transform_python()`` and ``transform_bson()`` methods.

The type codec for the custom type must define how to convert a
``~decimal.Decimal`` instance into a
``~bson.decimal128.Decimal128`` instance and vice-versa. 

Use the ``TypeCodec`` base class to define your codec:

.. code-block:: python

   >>> from bson.decimal128 import Decimal128
   >>> from bson.codec_options import TypeCodec
   >>> class DecimalCodec(TypeCodec):
   ...     python_type = Decimal  # the Python type acted upon by this type codec
   ...     bson_type = Decimal128  # the BSON type acted upon by this type codec
   ...     def transform_python(self, value):
   ...         """Function that transforms a custom type value into a type
   ...         that BSON can encode."""
   ...         return Decimal128(value)
   ...     def transform_bson(self, value):
   ...         """Function that transforms a vanilla BSON type value into our
   ...         custom type."""
   ...         return value.to_decimal()
   ...
   >>> decimal_codec = DecimalCodec()

.. _custom-type-type-registry:

The ``~bson.codec_options.TypeRegistry`` Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 3.8

Before encoding and decoding the custom type objects,
you must inform PyMongo about the corresponding codec. Do this by creating
a ``~bson.codec_options.TypeRegistry`` instance:

.. code-block:: python

   >>> from bson.codec_options import TypeRegistry
   >>> type_registry = TypeRegistry([decimal_codec])

.. note::
 
   You can instantiate type registries with any number of type codecs.
   Once instantiated, registries are immutable. You can only add codecs
   to a registry by creating a new one.

Putting It Together
-------------------

Finally, define a ``~bson.codec_options.CodecOptions`` instance
with your ``type_registry`` and use it to get a
``~pymongo.collection.Collection`` object that understands the
``~decimal.Decimal`` data type:

.. code-block:: python

   >>> from bson.codec_options import CodecOptions
   >>> codec_options = CodecOptions(type_registry=type_registry)
   >>> collection = db.get_collection("test", codec_options=codec_options)

Now you can encode and decode instances of
``~decimal.Decimal`` as shown in the following example:

.. code-block:: python

   >>> collection.insert_one({"num": Decimal("45.321")})
   InsertOneResult(ObjectId('...'), acknowledged=True)
   >>> mydoc = collection.find_one()
   >>> import pprint
   >>> pprint.pprint(mydoc)
   {'_id': ObjectId('...'), 'num': Decimal('45.321')}

Use a new object without the customized codec options to see the saved document in
the database:

.. code-block:: python

   >>> vanilla_collection = db.get_collection("test")
   >>> pprint.pprint(vanilla_collection.find_one())
   {'_id': ObjectId('...'), 'num': Decimal128('45.321')}

Encoding Subtypes
~~~~~~~~~~~~~~~~~

{+driver-short+} can also encode a type that subclasses
``Decimal``. It does this automatically for types that inherit from
Python types that are BSON-encodable by default.

Consider this subtype of ``Decimal`` that has a method to return its value as
an integer:

.. code-block:: python

   >>> class DecimalInt(Decimal):
   ...     def my_method(self):
   ...         """Method implementing some custom logic."""
   ...         return int(self)
   ...

If you save an instance of this type without first registering a type
codec for it, the driver raises an error:

.. code-block:: python

   >>> collection.insert_one({"num": DecimalInt("45.321")})
   Traceback (most recent call last):
   ...
   bson.errors.InvalidDocument: cannot encode object: Decimal('45.321'), of type: <class 'decimal.Decimal'>

To proceed further, you must define a type codec for ``DecimalInt``:

.. code-block:: python

   >>> class DecimalIntCodec(DecimalCodec):
   ...     @property
   ...     def python_type(self):
   ...         """The Python type acted upon by this type codec."""
   ...         return DecimalInt
   ...
   >>> decimalint_codec = DecimalIntCodec()

.. note::

   This example considers only the situation where a user wants to encode
   documents containing ``Decimal`` or ``DecimalInt`` subtypes.

After creating a new codec options object and using it to get a collection
object, you can encode instances of ``DecimalInt``:

.. code-block:: python

   >>> type_registry = TypeRegistry([decimal_codec, decimalint_codec])
   >>> codec_options = CodecOptions(type_registry=type_registry)
   >>> collection = db.get_collection("test", codec_options=codec_options)
   >>> collection.drop()
   >>> collection.insert_one({"num": DecimalInt("45.321")})
   InsertOneResult(ObjectId('...'), acknowledged=True)
   >>> mydoc = collection.find_one()
   >>> pprint.pprint(mydoc)
   {'_id': ObjectId('...'), 'num': Decimal('45.321')}

The ``transform_bson`` method of the base codec class results in
these values being decoded as ``Decimal`` (and not ``DecimalInt``).

.. _decoding-binary-types:

Decoding ``~bson.binary.Binary`` Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The decoding treatment of ``~bson.binary.Binary`` types having
``subtype = 0`` by the ``bson`` module varies slightly depending on the
version of the Python runtime in use. This must be taken into account while
writing a ``TypeDecoder`` that modifies how to decode this datatype.

On Python 3.x, ``~bson.binary.Binary`` data (``subtype = 0``) decodes
as a ``bytes`` instance:

.. code-block:: pycon

     >>> # On Python 3.x.
     >>> from bson.binary import Binary
     >>> newcoll = db.get_collection("new")
     >>> newcoll.insert_one({"_id": 1, "data": Binary(b"123", subtype=0)})
     >>> doc = newcoll.find_one()
     >>> type(doc["data"])
     bytes


On Python 2.7.x, the same data decodes as a ``~bson.binary.Binary``
instance:

.. code-block:: pycon

   >>> # On Python 2.7.x
   >>> newcoll = db.get_collection("new")
   >>> doc = newcoll.find_one()
   >>> type(doc["data"])
   bson.binary.Binary

As a consequence of this disparity, you must set the ``bson_type`` attribute
on your ``~bson.codec_options.TypeDecoder`` classes differently,
depending on the python version in use.

.. note::

  For applications requiring compatibility with both Python 2 and 3,
  register type decoders for both possible ``bson_type`` values.

.. _fallback-encoder-callable:

The ``fallback_encoder`` Callable
---------------------------------

.. versionadded:: 3.8

You can also register a callable to encode types
that BSON doesn't recognize and for which no type codec has been registered.
This callable is the **fallback encoder**, and like the ``transform_python``
method, it accepts an unencodable value as a parameter and returns a
BSON-encodable value. 

The following fallback encoder encodes python's ``~decimal.Decimal`` type to a ``~bson.decimal128.Decimal128``:

.. code-block:: python

   >>> def fallback_encoder(value):
   ...     if isinstance(value, Decimal):
   ...         return Decimal128(value)
   ...     return value
   ...

After declaring the callback, create a type registry and codec options
with this fallback encoder before initializing a collection:

.. code-block:: python

   >>> type_registry = TypeRegistry(fallback_encoder=fallback_encoder)
   >>> codec_options = CodecOptions(type_registry=type_registry)
   >>> collection = db.get_collection("test", codec_options=codec_options)
   >>> collection.drop()

You can now encode instances of ``~decimal.Decimal``:

.. code-block:: python

   >>> collection.insert_one({"num": Decimal("45.321")})
   InsertOneResult(ObjectId('...'), acknowledged=True)
   >>> mydoc = collection.find_one()
   >>> pprint.pprint(mydoc)
   {'_id': ObjectId('...'), 'num': Decimal128('45.321')}

.. note::

   {+driver-short+} invokes fallback encoders *after* attempts to encode the particular value
   with standard BSON encoders and any configured type encoders have failed.
   Therefore, in a type registry configured with a type encoder and fallback
   encoder that both target the same custom type, the behavior specified in
   the type encoder prevails.

Encoding Unknown Types
~~~~~~~~~~~~~~~~~~~~~~

This example describes how to use a fallback encoder to save
arbitrary objects to the database. It uses the standard library's
``pickle`` module to serialize the unknown types, and works only for types that
are picklable.

First, define some arbitrary custom types:

.. code-block:: python

   class MyStringType(object):
       def __init__(self, value):
           self.__value = value

       def __repr__(self):
           return "MyStringType('%s')" % (self.__value,)

   class MyNumberType(object):
       def __init__(self, value):
           self.__value = value

       def __repr__(self):
           return "MyNumberType(%s)" % (self.__value,)

Define a fallback encoder that pickles whatever objects it receives
and returns them as ``~bson.binary.Binary`` instances with a custom
subtype. The custom subtype allows you to write a TypeDecoder that
identifies pickled artifacts on retrieval and transparently decodes them
back into Python objects:

.. code-block:: python

   import pickle
   from bson.binary import Binary, USER_DEFINED_SUBTYPE


   def fallback_pickle_encoder(value):
       return Binary(pickle.dumps(value), USER_DEFINED_SUBTYPE)


   class PickledBinaryDecoder(TypeDecoder):
       bson_type = Binary

       def transform_bson(self, value):
           if value.subtype == USER_DEFINED_SUBTYPE:
               return pickle.loads(value)
           return value

.. note::

   The preceding example assumes the use of Python 3. If you are using
   Python 2, you must set ``bson_type`` to ``Binary``. See the
   :ref:`decoding-binary-types` section for a detailed explanation.

Finally, create a ``CodecOptions`` instance:

.. code-block:: python

   codec_options = CodecOptions(
       type_registry=TypeRegistry(
           [PickledBinaryDecoder()], fallback_encoder=fallback_pickle_encoder
       )
   )

You can now round-trip your custom objects to MongoDB:

.. code-block:: python

   collection = db.get_collection("test_fe", codec_options=codec_options)
   collection.insert_one(
       {"_id": 1, "str": MyStringType("hello world"), "num": MyNumberType(2)}
   )
   mydoc = collection.find_one()
   assert isinstance(mydoc["str"], MyStringType)
   assert isinstance(mydoc["num"], MyNumberType)

Limitations
-----------

PyMongo's type codec and fallback encoder features have the following
limitations:

- You cannot customize the encoding behavior of Python types that PyMongo
  already understands, such as ``int`` and ``str``.
  Attempting to instantiate a type registry with one or more codecs that act
  on a built-in type results in a ``TypeError``. This limitation extends
  to all subtypes of the standard types.
- Chaining type encoders is not supported. A custom type value, once
  transformed by a codec's ``transform_python`` method, *must* result in a
  type that is BSON-encodable by default, or that can be
  transformed by the fallback encoder into something BSON-encodable. You
  *cannot* transform it a second time by a different type codec.
- The ``~pymongo.database.Database.command`` method does not apply the
  user's TypeDecoders while decoding the command response document.
- ``gridfs`` does not apply custom type encoding or decoding to any
  documents received from, or returned to, the user.
