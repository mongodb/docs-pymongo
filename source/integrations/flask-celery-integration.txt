.. _pymongo-flask-celery:
.. original URL: https://www.mongodb.com/developer/products/mongodb/python-flask-celery-newsletter/

======================================
Tutorial: Celery and Flask Integration
======================================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: tutorial
 
.. meta::
   :keywords: flask, celery, integration, code example

Overview
--------

In this tutorial, you can learn how to build a newsletter platform using
MongoDB, Celery, and Flask. This application allows users to subscribe to
newsletters, and administrators to manage and send batch emails asynchronously.

Celery
~~~~~~

Celery is an open-source distributed task queue that makes handling large
volumes of messages efficiently. It supports asynchronous processing and task
scheduling. For more information, see the `Celery webpage
<https://docs.celeryq.dev/en/main/index.html>`__.

Flask
~~~~~

Flask is a lightweight web application framework with built-in configuration and
convention defaults that provide consistency to developers across projects. For
more information, see the `Flask webpage
<https://flask.palletsprojects.com/en/stable/>`__. 

Tutorial
--------

This tutorial creates a modified version of the sample application in the
:github:`Newsletter Platform with JavaScript, Flask, and MongoDB sample project
</mercybassey/newsletter-javascript-flask-mongodb>` GitHub repository.

Prerequisites
~~~~~~~~~~~~~

Ensure you have the following components installed and set up before you start
this tutorial:

- A MongoDB Cluster. We recommend setting up a cluster using Atlas. See the
  :atlas:`Get Started with Atlas </getting-started?tck=docs_driver_python>` page
  in the Atlas documentation.
- A database in your cluster called ``newsletter``. For more information, see
  the :atlas:`Create a Database </atlas-ui/databases/#create-a-database>` page
  in the Atlas guide.
- `RabbitMQ <https://www.rabbitmq.com/docs/download>`__ (message broker for Celery)
- `Gmail <www.gmail.com>`__ (to use as an SMTP)
- `Python 3.8 or later <https://www.python.org/downloads/>`__

Set-up
~~~~~~

.. procedure::
   :style: connected

   .. step:: Create your project directory and structure.
      
      The ``newsletter`` directory your the project directory for this tutorial. You can open 

      .. code-block:: bash

         mkdir newsletter
         cd newsletter

      - ``app.py``: The main entry point for your Flask application.
      - ``config.py``: Configuration settings for your application, including
        MongoDB connection details, mail server configuration, Celery broker
        connection, and any other environment-specific variables.   
      - ``tasks.py``: Defines background tasks to send emails asynchronously. 
      - ``routes.py``: Define the routes (URLs) that your application responds to.

      We recommend structuring your application to separate concerns, which can
      make the application modular and more maintainable. 
      
      In your project directory, create the following structure:

      .. code-block:: none

         newsletter/
         ├── app.py
         ├── config.py
         ├── routes.py
         ├── tasks.py
         ├── templates/
         │   ├── admin.html
         │   └── subscribe.html
         └── static/
             └── styles.css

   .. step:: Install the required Python packages.

      Your application depends on the following libraries:

      - `Flask <https://flask.palletsprojects.com/en/stable/>`__ for handling the web server and routing
      - `Flask Mail <https://pypi.org/project/Flask-Mail/>`__ for sending emails from your application
      - :ref:`{+driver-short+} <pymongo-get-started-download-and-install>`
      - `Celery <https://docs.celeryq.dev/en/stable/>`__ to manage tasks, such
        as sending batch emails

      .. tip:: Use a Virtual environment

         Installing your Python dependencies in a `virtualenv
         <https://docs.python.org/3/tutorial/venv.html>`__ allows you to install
         versions of your libraries for individual projects. Before running any
         ``pip`` commands, ensure your ``virtualenv`` is active.  
    
      Run the following ``pip`` command in your terminal to install the dependencies:

      .. code-block:: bash

         pip install Flask Flask-Mail pymongo celery

Configure Your Application
~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``config.py`` file contains the settings and credentials to perform the
following actions:

- Connect Celery to RabbitMQ as its message broker
- Configure Flask-Mail to use Gmail as its SMPT server
- Connect your application to your MongoDB server

Define the necessary configurations by adding the following code to your
``config.py`` file:

.. code-block:: python

   import os

   class Config:
      MAIL_SERVER = 'smtp.gmail.com'
      MAIL_PORT = 587
      MAIL_USE_TLS = True
      MAIL_USERNAME = '<username>' # Your email address without the domain, that is without '@gmail.com'
      MAIL_PASSWORD = '<app password>'
      ALLOWED_IPS = ['127.0.0.1']
      MONGO_URI = '<connection-string>'
      CELERY_BROKER_URL = 'amqp://guest:guest@localhost//'
      RESULT_BACKEND = MONGO_URI + '/celery_results'

You must provide your Gmail credentials (``MAIL_USERNAME`` and ``MAIL_PASSWORD``) to
enable your application to send emails. For security purposes, we recommend that
you generate an app password to use, rather than using your primary password.
For more information, see the `App Password settings
<https://myaccount.google.com/apppasswords>`__ in your Google Account.
 
You must also create a connection string (``MONGO_URI``) are set in your
environment variables. For more information see the :ref:`Create a Connection
String <pymongo-get-started-connection-string>` section of this guide

The provided broker url (``CELERY_BROKER_URL``) using RabbitMQ as the broker,
but you can customize this url to support other implementations. For more
information, see the `Broker Settings
<https://docs.celeryq.dev/en/stable/userguide/configuration.html#broker-settings>`__
section of the Celery documentation.

Initialize Flask, MongoDB, and Celery
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Initialize Flask, MongoDB, and Celery by adding the following code to your
``app.py`` file:

.. code-block:: python

   from flask import Flask
   from flask_mail import Mail
   from pymongo import MongoClient
   from celery import Celery

   app = Flask(__name__)
   app.config.from_object('config.Config')

   mail = Mail(app)
   client = MongoClient(app.config['MONGO_URI'])
   db = client.get_database(name="newsletter")

   celery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])
   celery.conf.update(app.config)

   from routes import *
   from tasks import *

   if __name__ == '__main__':
      app.run(debug=True)

This opens a connection to the ``newsletter`` database in your MongoDB cluster,
and configures your Celery task queue.

Define Your Routes
~~~~~~~~~~~~~~~~~~

Define the root, admin, subscribe, and send-newsletter routes by adding the following code to your ``routes.py`` file:

.. code-block:: python

   from flask import render_template, request, abort, jsonify
   from app import app, db
   from tasks import send_emails

   @app.before_request
   def limit_remote_addr():
      if 'X-Forwarded-For' in request.headers:
         remote_addr = request.headers['X-Forwarded-For'].split(',')[0]
      else:
         remote_addr = request.remote_addr
      
      if request.endpoint == 'admin' and remote_addr not in app.config['ALLOWED_IPS']:
         abort(403)

   @app.route('/')
   def home():
      return render_template('subscribe.html')

   @app.route('/admin')
   def admin():
      return render_template('admin.html')

   @app.route('/subscribe', methods=['POST'])
   def subscribe():
      first_name = request.form['firstname']
      last_name = request.form['lastname']
      email = request.form['email']

      if db.users.find_one({'email': email}):
         return """
         <div class="response error">
               <span class="icon">&#x2716;</span> This email is already subscribed!
         </div>
         """, 409

      db.users.insert_one({'firstname': first_name, 'lastname': last_name, 'email': email, 'subscribed': True})
      return """
      <div class="response success">
         <span class="icon">&#x2714;</span> Subscribed successfully!
      </div>
      """, 200

   @app.route('/send-newsletters', methods=['POST'])
   def send_newsletters():
      title = request.form['title']
      body = request.form['body']
      subscribers = list(db.users.find({'subscribed': True}))

      for subscriber in subscribers:
         subscriber['_id'] = str(subscriber['_id'])

      send_emails.apply_async(args=[subscribers, title, body])
      return jsonify({'message': 'Emails are being sent!'}), 202

You can add more security protections or customize user-facing alerts for your
application in this file.

Create Your Pages 
~~~~~~~~~~~~~~~~~

In the ``templates`` directory you can build your user interface.

Copy the following code into your ``subscribe.html`` file:

.. code-block:: html 

   <!DOCTYPE html>
   <html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Subscribe to Newsletter</title>
      <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
   </head>
   <body>
      <h1>Subscribe to our Newsletter</h1>
      <form id="subscribe-form">
         <label for="firstname">First Name:</label>
         <input type="text" id="firstname" name="firstname" required>
         <br>
         <label for="lastname">Last Name:</label>
         <input type="text" id="lastname" name="lastname" required>
         <br>
         <label for="email">Email:</label>
         <input type="email" id="email" name="email" required>
         <br>
         <button type="submit">Subscribe</button>
      </form>
      <div id="response"></div>
      <script>
         document.getElementById('subscribe-form').addEventListener('submit', function(event) {
               event.preventDefault();
               var formData = new FormData(event.target);
               fetch('/subscribe', {
                  method: 'POST',
                  body: formData
               }).then(response => {
                  if (!response.ok) {
                     throw response;
                  }
                  return response.text();
               }).then(data => {
                  document.getElementById('response').innerHTML = data;
                  document.getElementById('subscribe-form').reset();
                  setTimeout(() => {
                     document.getElementById('response').innerHTML = '';
                  }, 3000);
               }).catch(error => {
                  error.text().then(errorMessage => {
                     document.getElementById('response').innerHTML = errorMessage;
                     setTimeout(() => {
                           document.getElementById('response').innerHTML = '';
                     }, 3000);
                  });
               });
         });
      </script>
   </body>
   </html>

Because this application uses asynchronous messages, the script in this file
uses Fetch API calls. This script also handles timeouts and errors.

Copy the following code into your ``admin.html`` file:

.. code-block:: html 

   <!DOCTYPE html>
   <html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Admin - Send Newsletter</title>
      <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
   </head>
   <body>
      <h1>Send Newsletter</h1>
      <form id="admin-form">
         <label for="title">Title:</label>
         <input type="text" id="title" name="title" required>
         <br>
         <label for="body">Body:</label>
         <textarea id="body" name="body" required></textarea>
         <br>
         <button type="submit">Send</button>
      </form>
      <div id="response"></div> 
      <script>
         document.getElementById('admin-form').addEventListener('submit', function(event) {
               event.preventDefault();
               var formData = new FormData(event.target);
               fetch('/send-newsletters', {
                  method: 'POST',
                  body: formData
               })
               .then(response => response.json())
               .then(() => {
                  document.getElementById('response').innerText = 'Emails are being sent!';
                  setTimeout(() => {
                     document.getElementById('response').innerText = '';
                  }, 3000);
                  document.getElementById('admin-form').reset();
               })
               .catch(error => {
                  document.getElementById('response').innerText = 'Error sending emails.';
                  setTimeout(() => {
                     document.getElementById('response').innerText = '';
                  }, 3000);
                  console.error('Error:', error);
               });
         });
      </script>
   </body>
   </html>

The script in this file also used Fetch for asynchronous calls. It also displays
an alert to the user which depends on the success of the ``send_newsletter``
call.

Format Your Pages
~~~~~~~~~~~~~~~~~

You can apply a style sheet to your templates by adding the following code to
the ``styles.css`` file:

.. code-block:: css 

   body {
      font-family: system-ui;
      font-optical-sizing: auto;
      font-weight: 300;
      font-style: normal;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #040100;
   }

   h1 {
      color: white;
   }

   form {
      background: #023430;
      padding: 30px 40px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 400px;
      margin: 20px 0;
   }

   label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      color: white;
   }

   input[type="text"],
   input[type="email"],
   textarea {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 16px;
   }

   button {
      background: #00ED64;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      font-family: "Nunito", sans-serif;
   }

   button:hover {
      background: #00684A;
   }

   #response {
      margin-top: 20px;
      font-size: 16px;
      color: #28a745;
   }

   footer {
      text-align: center;
      padding: 20px;
      margin-top: 20px;
      font-size: 16px;
      color: #666;
   }

You can modify this style sheet or create your own to customize your
application. 

Testing the Platform
~~~~~~~~~~~~~~~~~~~~

After you complete the previous steps, you have a working application that
uses MongoDB, Flask and Celery to manage a newsletter platform.

You can use the following steps to test your application:

.. procedure::
   :style: connected

   .. step::  Start your background services.

      Start your RabbitMQ node by running the following code:

      .. code-block:: bash

         brew services start rabbitmq

   .. step::  Start your application.

      Use the following code to start your application:

      .. code-block:: bash

         flask --app app run

      In another terminal, start the Celery worker:

      .. code-block:: bash

         celery -A app.celery worker --loglevel=info

   .. step::  Create a subscriber.

      Navigate to ``localhost:5000`` in your browser to open the
      :guilabel:`Subscribe to our Newsletter` page.

      Enter the subscriber information and click :guilabel:`Subscribe`.

      To confirm that you created a new subscriber, open `Atlas
      <https://account.mongodb.com/account/login>`__ and navigate to the
      ``users`` collection in your ``newletter`` database. 

   .. step::  Dispatch a newsletter.

      Navigate to ``localhost:5000/admin`` in your browser to open the
      :guilabel:`Send Newsletter` page. Enter the newsletter details and click
      :guilabel:`Send`. 

      Your Celery worker log will display an ``Email sent`` log entry, as
      shown in the following image:

      .. code-block:: bash

         [2025-05-27 09:54:43,873: INFO/ForkPoolWorker-7] Task tasks.send_emails[7d7f9616-7b9b-4508-a889-95c35f54fe43] succeeded in 3.93334774998948s: {'result': 'All emails sent'}
         [2025-05-27 10:04:52,043: INFO/MainProcess] Task tasks.send_emails[ac2ec70f-2d3e-444a-95bb-185ac659f460] received
         [2025-05-27 10:04:52,046: WARNING/ForkPoolWorker-7] Sending email to <subscriber_email>
         [2025-05-27 10:04:53,474: WARNING/ForkPoolWorker-7] Email sent

      You can also confirm that you sent an email navigating to the
      ``deliveries`` collection in your ``newletter`` database. 

Next Steps
~~~~~~~~~~

This application demonstrates how to integrate with the Celery tasks task queue to
manage subscriber data, and send batch emails. You can further enhance this
platform by integrating analytics, customizing email templates, and implementing
automated responses.

More Resources
--------------

For more information about to components used in this tutorial, see the following
resources:

- `Flask <https://flask.palletsprojects.com>`__
- `Flask Mail <https://pypi.org/project/Flask-Mail/#files>`__
- `Celery <https://docs.celeryq.dev/en/stable/>`__
- :mdb-shell:`MongoDB Shell <>`

For support or to contribute to the MongoDB Community, see the `MongoDB Developer Community <https://www.mongodb.com/community/>`__.