.. docs-landing/source/languages/python.txt

Can {+driver-short+} Load the Results of a Query as a Pandas DataFrame?
-----------------------------------------------------------------------

You can use the `PyMongoArrow <https://www.mongodb.com/docs/languages/python/pymongo-arrow-driver/current/>`__
library to work with numerical or columnar data. PyMongoArrow lets you 
load MongoDB query result-sets as
`Pandas DataFrames <https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html>`__,
`NumPy ndarrays <https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html>`__, or
`Apache Arrow Tables <https://arrow.apache.org/docs/python/generated/pyarrow.Table.html>`__.

How Can I Encode My Documents to JSON?
--------------------------------------

{+driver-short+} supports some special types, like ``ObjectId``
and ``DBRef``, that aren't supported in JSON. Therefore, Python's ``json`` module won't
work with all documents in {+driver-short+}. Instead, {+driver-short+} includes the
`json_util <https://pymongo.readthedocs.io/en/latest/api/bson/json_util.html>`__
module, a tool for using Python's ``json`` module with BSON documents and
`MongoDB Extended JSON <https://mongodb.com/docs/manual/reference/mongodb-extended-json/>`__. 

`python-bsonjs <https://pypi.python.org/pypi/python-bsonjs>`__ is another
BSON-to-MongoDB-Extended-JSON converter, built on top of
`libbson <https://github.com/mongodb/libbson>`__. python-bsonjs doesn't
depend on {+driver-short+} and might offer a performance improvement over
``json_util`` in certain cases.

.. tip::
   
   python-bsonjs works best with {+driver-short+} when using the ``RawBSONDocument``
   type.

Does {+driver-short+} Behave Differently in Python 3?
-----------------------------------------------------

{+driver-short+} encodes instances of the ``bytes`` class
as BSON type 5 (binary data) with subtype 0.
In Python 2, these instances are decoded to ``Binary``
with subtype 0. In Python 3, they are decoded back to ``bytes``. 

The following code examples use {+driver-short+} to insert a ``bytes`` instance
into MongoDB, and then find the instance.
In Python 2, the byte string is decoded to ``Binary``.
In Python 3, the byte string is decoded back to ``bytes``.

.. tabs::

   .. tab:: Python 2.7
      :tabid: python-2

      .. code-block:: python

         >>> import pymongo
         >>> c = pymongo.MongoClient()
         >>> c.test.bintest.insert_one({'binary': b'this is a byte string'}).inserted_id
         ObjectId('4f9086b1fba5222021000000')
         >>> c.test.bintest.find_one()
         {u'binary': Binary('this is a byte string', 0), u'_id': ObjectId('4f9086b1fba5222021000000')}
 
   .. tab:: Python 3.7
      :tabid: python-3

      .. code-block:: python

         >>> import pymongo
         >>> c = pymongo.MongoClient()
         >>> c.test.bintest.insert_one({'binary': b'this is a byte string'}).inserted_id
         ObjectId('4f9086b1fba5222021000000')
         >>> c.test.bintest.find_one()
         {'binary': b'this is a byte string', '_id': ObjectId('4f9086b1fba5222021000000')}

Similarly, Python 2 and 3 behave differently when {+driver-short+} parses JSON binary
values with subtype 0. In Python 2, these values are decoded to instances of ``Binary``
with subtype 0. In Python 3, they're decoded into instances of ``bytes``. 

The following code examples use the ``json_util`` module to decode a JSON binary value
with subtype 0. In Python 2, the byte string is decoded to ``Binary``.
In Python 3, the byte string is decoded back to ``bytes``.

.. tabs::

   .. tab:: Python 2.7
      :tabid: python-2

      .. code-block:: python

         >>> from bson.json_util import loads
         >>> loads('{"b": {"$binary": "dGhpcyBpcyBhIGJ5dGUgc3RyaW5n", "$type": "00"}}')
         {u'b': Binary('this is a byte string', 0)}

   .. tab:: Python 3.7
      :tabid: python-3

      .. code-block:: python

         >>> from bson.json_util import loads
         >>> loads('{"b": {"$binary": "dGhpcyBpcyBhIGJ5dGUgc3RyaW5n", "$type": "00"}}')
         {'b': b'this is a byte string'}

Can I Share Pickled ObjectIds Between Python 2 and Python 3?
------------------------------------------------------------

If you use Python 2 to pickle an instance of ``ObjectId``,
you can always unpickle it with Python 3. To do so, you must pass
the ``encoding='latin-1'`` option to the ``pickle.loads()`` method.
The following code example shows how to pickle an ``ObjectId`` in Python 2.7, and then
unpickle it in Python 3.7:

.. code-block:: python
   :emphasize-lines: 12 

   # Python 2.7
   >>> import pickle
   >>> from bson.objectid import ObjectId
   >>> oid = ObjectId()
   >>> oid
   ObjectId('4f919ba2fba5225b84000000')
   >>> pickle.dumps(oid)
   'ccopy_reg\n_reconstructor\np0\n(cbson.objectid\...'

   # Python 3.7
   >>> import pickle
   >>> pickle.loads(b'ccopy_reg\n_reconstructor\np0\n(cbson.objectid\...', encoding='latin-1')
   ObjectId('4f919ba2fba5225b84000000')

If you pickled an ``ObjectID`` in Python 2, and want to unpickle it in Python 3,
you must pass the ``protocol`` argument with a value of ``2`` or less to the
``pickle.dumps()`` method.
The following code example shows how to pickle an ``ObjectId`` in Python 3.7, and then
unpickle it in Python 2.7:

.. code-block:: python
   :emphasize-lines: 7

   # Python 3.7
   >>> import pickle
   >>> from bson.objectid import ObjectId
   >>> oid = ObjectId()
   >>> oid
   ObjectId('4f96f20c430ee6bd06000000')
   >>> pickle.dumps(oid, protocol=2)
   b'\x80\x02cbson.objectid\nObjectId\nq\x00)\x81q\x01c_codecs\nencode\...'

   # Python 2.7
   >>> import pickle
   >>> pickle.loads('\x80\x02cbson.objectid\nObjectId\nq\x00)\x81q\x01c_codecs\nencode\...')
   ObjectId('4f96f20c430ee6bd06000000')
